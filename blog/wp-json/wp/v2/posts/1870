{"id":1870,"date":"2024-05-10T06:52:10","date_gmt":"2024-05-10T06:52:10","guid":{"rendered":"https:\/\/www.skillvertex.com\/blog\/?p=1870"},"modified":"2024-05-10T06:52:10","modified_gmt":"2024-05-10T06:52:10","slug":"const-qualifier-in-c","status":"publish","type":"post","link":"https:\/\/www.skillvertex.com\/blog\/const-qualifier-in-c\/","title":{"rendered":"Const Qualifier In C"},"content":{"rendered":"\n<div class=\"wp-block-rank-math-toc-block\" id=\"rank-math-toc\" id=\"rank-math-toc\"><p>Table of Contents<\/p><nav><ul><li ><a href=\"#const-qualifier-in-c\">Const Qualifier In C<\/a><\/li><li ><a href=\"#what-is-a-const-qualifier\">What is a Const Qualifier <\/a><ul><li ><a href=\"#1-constant-variables\"> 1. Constant Variables<\/a><\/li><li ><a href=\"#2-pointer-to-constant\">2. Pointer to Constant<\/a><\/li><li ><a href=\"#3-constant-pointer-to-variable\">3. Constant Pointer to Variable<\/a><\/li><\/ul><\/li><li ><a href=\"#advantages-of-const-qualifier-in-c\">Advantages of const Qualifier In C<\/a><\/li><li ><a href=\"#faq-const-qualifier-in-c\">FAQ &#8211; Const Qualifier In C<\/a><\/li><\/ul><\/nav><\/div>\n\n\n\n<h2 class=\"wp-block-heading\" id=\"const-qualifier-in-c\">Const Qualifier In C<\/h2>\n\n\n\n<p>In C programming, there&#8217;s something called the &#8220;const&#8221; qualifier. It&#8217;s like a rule that says once you set a value to something, you can&#8217;t change it. This is really important because it helps make sure data in a program stays reliable and doesn&#8217;t get messed up accidentally. In this discussion about &#8220;const&#8221; in C, we&#8217;ll look at how to use it and why it&#8217;s useful for C programmers. Knowing about &#8220;const&#8221; is a big part of writing code in C that&#8217;s strong and easy to understand.<\/p>\n\n\n\n<h2 class=\"wp-block-heading\" id=\"what-is-a-const-qualifier\">What is a Const Qualifier <\/h2>\n\n\n\n<p>You can use the &#8220;const&#8221; qualifier in C to declare a variable and make sure it doesn&#8217;t change its value. However, it&#8217;s important to note that, depending on where the const variable is stored, you might still be able to change its value using a pointer, but this isn&#8217;t recommended.<\/p>\n\n\n\n<p>Using &#8220;const&#8221; in C is a good idea when you want to make sure certain values stay the same and don&#8217;t get accidentally changed. It&#8217;s a way to keep your code reliable and prevent unexpected modifications.<\/p>\n\n\n\n<h3 class=\"wp-block-heading\" id=\"1-constant-variables\"> 1. Constant Variables<\/h3>\n\n\n\n<pre class=\"wp-block-code\"><code>const int var = 100;\n<\/code><\/pre>\n\n\n\n<p>const is used to declare a variable&nbsp;<strong>var&nbsp;<\/strong>as a constant with an initial value of 100 in the given example. The value of this variable cannot be modified once it is initialized. Refer to the following example given :<\/p>\n\n\n\n<pre class=\"wp-block-code\"><code>\/\/ C program to demonstrate that constant variables can not\n\/\/ be modified\n#include &lt;stdio.h&gt;\n \nint main()\n{\n    const int var = 100;\n \n    \/\/ Compilation error: assignment of read-only variable\n    \/\/ 'var'\n    var = 200;\n \n    return 0;\n}<\/code><\/pre>\n\n\n\n<p><strong>Output <\/strong><\/p>\n\n\n\n<pre class=\"wp-block-code\"><code>.\/Solution.cpp: In function 'int main()':\n.\/Solution.cpp:11:9: error: assignment of read-only variable 'var'\n     var = 200;\n         ^<\/code><\/pre>\n\n\n\n<h3 class=\"wp-block-heading\" id=\"2-pointer-to-constant\">2. Pointer to Constant<\/h3>\n\n\n\n<pre class=\"wp-block-code\"><code>const int* ptr;\n<\/code><\/pre>\n\n\n\n<p>You can modify a pointer to point to a different integer variable, but you can&#8217;t change the value of the actual object (the thing it&#8217;s pointing to) using that pointer. The pointer itself is stored in an area where you can read and write data, like the stack. Refer to the example below:<\/p>\n\n\n\n<pre class=\"wp-block-code\"><code>\/\/ C program to demonstrate that  the pointer to point to\n\/\/ any other integer variable, but the value of the object\n\/\/ (entity) pointed can not be changed\n \n#include &lt;stdio.h&gt;\nint main(void)\n{\n    int i = 10;\n    int j = 20;\n    \/* ptr is pointer to constant *\/\n    const int* ptr = &amp;i;\n \n    printf(\"ptr: %d\\n\", *ptr);\n    \/* error: object pointed cannot be modified\n    using the pointer ptr *\/\n    *ptr = 100;\n \n    ptr = &amp;j; \/* valid *\/\n    printf(\"ptr: %d\\n\", *ptr);\n \n    return 0;\n}<\/code><\/pre>\n\n\n\n<p><strong>Output <\/strong><\/p>\n\n\n\n<pre class=\"wp-block-code\"><code>.\/Solution.c: In function 'main':\n.\/Solution.c:12:10: error: assignment of read-only location '*ptr'\n     *ptr = 100;\n          ^<\/code><\/pre>\n\n\n\n<p><strong>Example 2: Program where variable i itself is constant<\/strong><\/p>\n\n\n\n<pre class=\"wp-block-code\"><code>\n\/\/ C program to demonstrate that  the pointer to point to\n\/\/ any other integer variable, but the value of the object\n\/\/ (entity) pointed can not be changed\n \n#include &lt;stdio.h&gt;\n \nint main(void)\n{\n    \/* i is stored in read only area*\/\n    int const i = 10;\n    int j = 20;\n \n    \/* pointer to integer constant. Here i\n    is of type \"const int\", and &amp;i is of\n    type \"const int *\".  And p is of type\n    \"const int\", types are matching no issue *\/\n    int const* ptr = &amp;i;\n \n    printf(\"ptr: %d\\n\", *ptr);\n \n    \/* error *\/\n    *ptr = 100;\n \n    \/* valid. We call it up qualification. In\n    C\/C++, the type of \"int *\" is allowed to up\n    qualify to the type \"const int *\". The type of\n    &amp;j is \"int *\" and is implicitly up qualified by\n    the compiler to \"const int *\" *\/\n \n    ptr = &amp;j;\n    printf(\"ptr: %d\\n\", *ptr);\n \n    return 0;\n}<\/code><\/pre>\n\n\n\n<p>In C++ and C, down qualification is not allowed and can lead to issues or warnings. Down qualification occurs when you assign a qualified type (e.g., const-qualified) to a non-qualified type. This means that if you have a pointer or reference to a const-qualified object and you try to assign it to a non-const pointer or reference, it will likely result in a compilation error in C++<\/p>\n\n\n\n<p><strong>Example 3: Program to show down qualifications<\/strong><\/p>\n\n\n\n<pre class=\"wp-block-code\"><code>\n\/\/ C program to demonstrate the down qualification\n \n#include &lt;stdio.h&gt;\n \nint main(void)\n{\n    int i = 10;\n    int const j = 20;\n \n    \/* ptr is pointing an integer object *\/\n    int* ptr = &amp;i;\n \n    printf(\"*ptr: %d\\n\", *ptr);\n \n    \/* The below assignment is invalid in C++, results in\n       error In C, the compiler *may* throw a warning, but\n       casting is implicitly allowed *\/\n    ptr = &amp;j;\n \n    \/* In C++, it is called 'down qualification'. The type\n       of expression &amp;j is \"const int *\" and the type of ptr\n       is \"int *\". The assignment \"ptr = &amp;j\" causes to\n       implicitly remove const-ness from the expression &amp;j.\n       C++ being more type restrictive, will not allow\n       implicit down qualification. However, C++ allows\n       implicit up qualification. The reason being, const\n       qualified identifiers are bound to be placed in\n       read-only memory (but not always). If C++ allows\n       above kind of assignment (ptr = &amp;j), we can use 'ptr'\n       to modify value of j which is in read-only memory.\n       The consequences are implementation dependent, the\n       program may fail\n      at runtime. So strict type checking helps clean code.\n     *\/\n \n    printf(\"*ptr: %d\\n\", *ptr);\n \n    return 0;\n}<\/code><\/pre>\n\n\n\n<p><strong>Output <\/strong><\/p>\n\n\n\n<pre class=\"wp-block-code\"><code>main.c: In function \u2018main\u2019:\nmain.c:16:9: warning: assignment discards \u2018const\u2019 qualifier from pointer target type &#91;-Wdiscarded-qualifiers]\n   16 |     ptr = &amp;j;\n      |         ^\n*ptr: 10\n*ptr: 20<\/code><\/pre>\n\n\n\n<h3 class=\"wp-block-heading\" id=\"3-constant-pointer-to-variable\">3. Constant Pointer to Variable<\/h3>\n\n\n\n<pre class=\"wp-block-code\"><code>int* const ptr;\n<\/code><\/pre>\n\n\n\n<p>The declaration you provided is for a pointer to a constant integer, not a constant pointer to an integer. In C and C++, these two declarations have different meanings<br><\/p>\n\n\n\n<pre class=\"wp-block-code\"><code>\n\/\/ C program to demonstrate that value pointed by the\n\/\/ pointer can not be changed as well as we cannot point the\n\/\/ pointer to other variables\n \n#include &lt;stdio.h&gt;\n \nint main(void)\n{\n    int i = 10;\n    int j = 20;\n    \/* constant pointer to constant integer *\/\n    const int* const ptr = &amp;i;\n \n    printf(\"ptr: %d\\n\", *ptr);\n \n    ptr = &amp;j; \/* error *\/\n    *ptr = 100; \/* error *\/\n \n    return 0;\n}<\/code><\/pre>\n\n\n\n<p><strong>Output<\/strong><\/p>\n\n\n\n<pre class=\"wp-block-code\"><code>.\/Solution.c: In function 'main':\n.\/Solution.c:12:9: error: assignment of read-only variable 'ptr'\n     ptr = &amp;j; \/* error *\/\n         ^\n.\/Solution.c:13:10: error: assignment of read-only location '*ptr'\n     *ptr = 100; \/* error *\/\n          ^<\/code><\/pre>\n\n\n\n<h2 class=\"wp-block-heading\" id=\"advantages-of-const-qualifier-in-c\">Advantages of const Qualifier In C<\/h2>\n\n\n\n<p>Using the <code>const<\/code> keyword in your code offers several advantages:<\/p>\n\n\n\n<ol class=\"wp-block-list\">\n<li><strong>Improved Code Readability:<\/strong> When you mark a variable as <code>const<\/code>, you&#8217;re telling other programmers that its value shouldn&#8217;t change. This makes your code easier for others to understand and maintain.<\/li>\n\n\n\n<li><strong>Enhanced Type Safety:<\/strong> By using, you can prevent accidental modifications to values, reducing the chances of bugs and errors in your code. It adds an extra layer of protection.<\/li>\n\n\n\n<li><strong>Improved Optimization:<\/strong> Compilers can optimize <code>const<\/code> variables more effectively because they know these values won&#8217;t change during program execution. This optimization can result in faster and more efficient code.<\/li>\n\n\n\n<li><strong>Better Memory Usage:<\/strong> Declaring variables as <code>const<\/code> can often eliminate the need to create unnecessary copies of values, reducing memory usage and improving overall performance.<\/li>\n\n\n\n<li><strong>Improved Compatibility:<\/strong> Using <code>const<\/code> in your code can enhance compatibility with other libraries and APIs that also use <code>const<\/code> variables. It helps ensure that your code plays well with others.<\/li>\n\n\n\n<li><strong>Improved Reliability:<\/strong> <code>const<\/code> helps make your code more reliable by preventing unexpected value modifications, and reducing the risk of bugs and errors in your program.<\/li>\n<\/ol>\n\n\n\n<p>In summary, incorporating the <code>const<\/code> keyword in your code can lead to more readable, reliable, and optimized software while enhancing compatibility with other code and libraries.<\/p>\n\n\n\n<h2 class=\"wp-block-heading\" id=\"faq-const-qualifier-in-c\">FAQ &#8211; Const Qualifier In C<\/h2>\n\n\n<div id=\"rank-math-faq\" class=\"rank-math-block\">\n<div class=\"rank-math-list \">\n<div id=\"faq-question-1694681798997\" class=\"rank-math-list-item\">\n<h4 class=\"rank-math-question \">Q1.  What is the const qualifier?<\/h4>\n<div class=\"rank-math-answer \">\n\n<p>Ans. The const qualifier serves as a clear declaration that a data object&#8217;s value cannot be changed once it&#8217;s initialized. In other words, it&#8217;s a way of saying, &#8220;This thing won&#8217;t change after I set its value.&#8221; This means you can&#8217;t use const data objects in situations where a change is expected or required. For example, you can&#8217;t use a const data object on the left side of an assignment statement because it&#8217;s not allowed to be modified once it has a value.<\/p>\n\n<\/div>\n<\/div>\n<div id=\"faq-question-1694681807569\" class=\"rank-math-list-item\">\n<h4 class=\"rank-math-question \">Q2. Why do we require const qualifier in C with example?<\/h4>\n<div class=\"rank-math-answer \">\n\n<p>Ans. The const qualifier designates a variable as unchangeable after initialization. This is valuable for constants like PI, enhancing code readability and preventing errors.<\/p>\n\n<\/div>\n<\/div>\n<div id=\"faq-question-1694681817113\" class=\"rank-math-list-item\">\n<h4 class=\"rank-math-question \">Q3. What is const and volatile qualifier in C?<\/h4>\n<div class=\"rank-math-answer \">\n\n<p>Ans. The const keyword ensures a pointer can&#8217;t change after initialization, protecting it from modification. In contrast, the volatile keyword indicates that a value can be changed by external actions beyond the user&#8217;s control.<\/p>\n\n<\/div>\n<\/div>\n<\/div>\n<\/div>","protected":false},"excerpt":{"rendered":"<p>Const Qualifier In C In C programming, there&#8217;s something called the &#8220;const&#8221; qualifier. It&#8217;s like a rule that says once you set a value to something, you can&#8217;t change it. This is really important because it helps make sure data in a program stays reliable and doesn&#8217;t get messed up accidentally. In this discussion about &#8230; <a title=\"Const Qualifier In C\" class=\"read-more\" href=\"https:\/\/www.skillvertex.com\/blog\/const-qualifier-in-c\/\" aria-label=\"More on Const Qualifier In C\">Read more<\/a><\/p>\n","protected":false},"author":4,"featured_media":5276,"comment_status":"open","ping_status":"open","sticky":false,"template":"","format":"standard","meta":{"footnotes":""},"categories":[27],"tags":[316],"class_list":["post-1870","post","type-post","status-publish","format-standard","has-post-thumbnail","hentry","category-c-programming","tag-const-qualifier-in-c","generate-columns","tablet-grid-50","mobile-grid-100","grid-parent","grid-33"],"_links":{"self":[{"href":"https:\/\/www.skillvertex.com\/blog\/wp-json\/wp\/v2\/posts\/1870"}],"collection":[{"href":"https:\/\/www.skillvertex.com\/blog\/wp-json\/wp\/v2\/posts"}],"about":[{"href":"https:\/\/www.skillvertex.com\/blog\/wp-json\/wp\/v2\/types\/post"}],"author":[{"embeddable":true,"href":"https:\/\/www.skillvertex.com\/blog\/wp-json\/wp\/v2\/users\/4"}],"replies":[{"embeddable":true,"href":"https:\/\/www.skillvertex.com\/blog\/wp-json\/wp\/v2\/comments?post=1870"}],"version-history":[{"count":15,"href":"https:\/\/www.skillvertex.com\/blog\/wp-json\/wp\/v2\/posts\/1870\/revisions"}],"predecessor-version":[{"id":10607,"href":"https:\/\/www.skillvertex.com\/blog\/wp-json\/wp\/v2\/posts\/1870\/revisions\/10607"}],"wp:featuredmedia":[{"embeddable":true,"href":"https:\/\/www.skillvertex.com\/blog\/wp-json\/wp\/v2\/media\/5276"}],"wp:attachment":[{"href":"https:\/\/www.skillvertex.com\/blog\/wp-json\/wp\/v2\/media?parent=1870"}],"wp:term":[{"taxonomy":"category","embeddable":true,"href":"https:\/\/www.skillvertex.com\/blog\/wp-json\/wp\/v2\/categories?post=1870"},{"taxonomy":"post_tag","embeddable":true,"href":"https:\/\/www.skillvertex.com\/blog\/wp-json\/wp\/v2\/tags?post=1870"}],"curies":[{"name":"wp","href":"https:\/\/api.w.org\/{rel}","templated":true}]}}